### [JS] 모던 Javascript Deep Dive 17장 - 생성자 함수에 의한 객체 생성
---

10장 '객체 리터럴'에서 객체 리터럴에 의한 객체 생성 방식을 살펴보았다. 객체 리터럴에 의한 객체 생성 방식은 가장 일반적이고 간단한 객체 생성 방식이다. 그러나 자바스크립트에서는 객체를 생성할 수 있는 다양한 방법이 있으며, 이번 17장에서는 그중에서도 **생성자 함수**를 사용하여 객체를 생성하는 방법에 대해 다루어보겠다.

## 17.1 Object 생성자 함수

`Object` 생성자 함수는 `new` 연산자와 함께 호출하여 빈 객체(인스턴스)를 생성하는 함수이다.

```js
const person = new Object();
```

이렇게 생성된 객체는 초기에는 아무런 프로퍼티도 가지지 않으며, 필요에 따라 프로퍼티를 추가할 수 있다. 자바스크립트는 `Object` 생성자 함수 외에도 `String`, `Number`, `Boolean`, `Function`, `Array`, `Date`, `RegExp`, `Promise` 등의 빌트인 생성자 함수를 제공한다.

## 17.2 생성자 함수

### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점

객체 리터럴은 직관적이고 간편한 방식이지만, 단 하나의 객체만 생성할 수 있다는 한계가 있다. 동일한 프로퍼티를 갖는 여러 객체를 생성해야 할 때는 비효율적이다.

```js
const circle1 = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius;
  }
};

const circle2 = {
  radius: 10,
  getDiameter() {
    return 2*this.radius;
  }
}
```

객체 리터럴 방식의 단점은 중복을 처리하기 어렵고, 캡슐화가 불가능하다는 점, 그리고 프로토타입 상속이 복잡해진다는 점이 있다. 자바스크립트에서는 '프로토타입'이라는 메커니즘으로 상속을 구현하는데, 객체 리터럴로 객체를 생성하면 객체의 프로토타입은 기본적으로 `Object.prototype`으로 설정된다. 따라서 다른 객체의 프로토타입을 상속하려면 추가적인 작업이 필요해지고, 이는 코드의 복잡성을 높인다.

### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점

생성자 함수를 사용하면 객체를 쉽게 재사용할 수 있으며, 프로토타입 기반 상속과 캡슐화도 가능해진다.

```js
function Person(name) {
  this.name = name; // 재사용성
  let age = 0; // 캡슐화

  this.getAge = function() { // 캡슐화된 속성에 대한 접근자
    return age;
  }

  this.birthday = function() { // 캡슐화된 속성을 수정하는 메서드
    age++;
  }
}

Person.prototype.greet = function() { // 프로토타입 기반 상속
  console.log(`Hello, my name is ${this.name}`);
}

let person1 = new Person('John');
let person2 = new Person('Sarah');

person1.greet(); // "Hello, my name is John"
person2.greet(); // "Hello, my name is Sarah"

console.log(person1.getAge()); // 0
person1.birthday();
console.log(person1.getAge()); // 1
```

위 코드처럼, 생성자 함수는 동일한 구조의 객체를 반복해서 생성할 수 있는 장점이 있다. 또한 캡슐화를 통해 내부 상태를 외부로부터 숨길 수 있으며, 프로토타입을 활용하여 메서드를 공유할 수 있다. 이로 인해 메모리 사용을 효율화할 수 있다.

### 17.2.3 생성자 함수의 인스턴스 생성 과정

생성자 함수가 객체를 생성하는 과정은 다음과 같다:

1. **인스턴스 생성과 this 바인딩** : 먼저 빈 객체가 생성되고, 이 객체는 생성자 함수의 `this`에 바인딩된다. 생성자 함수 내부에서 `this`를 참조하면 새로 생성된 인스턴스를 가리키게 된다.

```js
function Person(name) {
  console.log(this); // Person {}
  this.name = name;
}
```

2. **인스턴스 초기화** : 생성자 함수 내부의 코드가 실행되면서 `this`에 바인딩된 인스턴스가 초기화된다. 즉, 필요한 프로퍼티를 추가하거나 메서드를 정의하는 작업이 이루어진다.

```js
function Person(name) {
  // 인스턴스 초기화
  this.name = name;
}
```

3. **인스턴스 반환** : 생성자 함수의 실행이 끝나면 `this`에 바인딩된 인스턴스가 암묵적으로 반환된다. 만약 생성자 함수에서 명시적으로 다른 객체를 반환하지 않으면, 자동으로 이 인스턴스가 반환된다.

```js
function Person(name) {
  this.name = name;
  // this 반환
}

let john = new Person('John');
console.log(john); // Person { name: 'John' }
```

### 17.2.4 내부 메서드 [[Call]]과 [[Construct]]

함수는 객체이지만 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 함수가 일반 함수로 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고, `new` 연산자와 함께 생성자 함수로 호출되면 [[Construct]]가 호출된다. 함수는 callable해야 하며, constructor일 수도 있고 non-constructor일 수도 있다.

- **[[Call]]**: 함수를 호출할 때 사용하는 내부 메서드이다. 모든 함수 객체는 [[Call]] 내부 메서드를 가지고 있으며, 이 메서드가 있어야 함수로서 호출할 수 있다.

```js
function sayHello() {
  console.log('Hello!');
}

// 함수를 호출하면 내부적으로 [[Call]] 메서드가 동작한다.
sayHello();  // 출력: Hello!
```

- **[[Construct]]**: `new` 연산자와 함께 생성자 함수를 호출할 때 사용하는 내부 메서드이다. 모든 생성자 함수는 [[Construct]] 내부 메서드를 가지고 있으며, 이 메서드가 있어야 `new` 키워드를 사용해 인스턴스를 생성할 수 있다.

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// new 키워드를 사용해 생성자 함수를 호출하면 내부적으로 [[Construct]] 메서드가 동작한다.
var person = new Person('John', 30);

console.log(person.name);  // 출력: John
console.log(person.age);   // 출력: 30
```

### 17.2.5 constructor와 non-constructor의 구분

생성자 함수는 `new` 키워드를 사용하여 인스턴스를 생성할 수 있는 함수이다. 생성자 함수는 일반적으로 첫 글자를 대문자로 작성하여 다른 개발자에게 생성자 함수임을 알린다.

```js
function Person(name) {
  this.name = name;
}

const john = new Person('John'); // 'new' 키워드를 사용하여 생성자 함수 호출
console.log(john.name); // 출력: 'John'
```

반면, 비생성자 함수(non-constructor)는 `new` 키워드와 함께 호출할 수 없다. 만약 `new` 키워드와 함께 호출하려고 시도하면, `TypeError`가 발생한다.

```js
const arrowFunc = () => {};
new arrowFunc(); // TypeError: arrowFunc is not a constructor
```

### 17.2.6 new 연산자

`new` 연산자는 객체를 생성하고 초기화하는 데 사용된다. 이 연산자는 생성자 함수를 호출하며, 그 과정에서 객체를 생성하고 반환한다.

```js
// 생성자 함수를 정의
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// new 연산자를 사용해 Person 객체를 생성
var person1 = new Person('John', 30);
var person2 = new Person('Jane', 25);

console.log(person1);  // Person { name: 'John', age: 30 }
console.log(person2);  // Person { name: 'Jane', age: 25 }
```

`new` 연산자와 함께 생성자 함수로서 호출하면, 함수 내부의 `this`는 생성될 인스턴스를 가리키지만, 일반 함수로 호출하면 함수 내부의 `this`는 전역 객체(`window`)를 가리킨다.

### 17.2.7 new.target

`new.target`은 ES6에서 도입된 메타 프로퍼티로, 생성자 함수나 클래스가 `new` 연산자를 통해 호출되었는지를 확인할 수 있게 해준다. 함수가 `new` 연산자 없이 호출되었을 경우, `new.target`은 `undefined` 값을 가지게 된다. 이를 활용하여 생성자 함수가 잘못된 방식으로 호출되는 것을 방지할 수 있다.

```js
function ExampleConstructor() {
    if (!new.target) {
        console.log('new 없이 호출되었음');
    } else {
        console.log('new와 함께 호출되었음');
    }
}

ExampleConstructor();  // 'new 없이 호출되었음' 출력
new ExampleConstructor();  // 'new와 함께 호출되었음' 출력
```

위의 예제에서 `new.target`을 활용하여 `new` 없이 호출된 경우와 `new`와 함께 호출된 경우를 구분하고 있다. `new.target`이 `undefined`일 때는 `new` 없이 호출된 것으로, 이를 통해 적절한 처리를 할 수 있다.

이와 같은 방어 코드 패턴은 실수로 `new`를 빼먹고 생성자 함수를 호출했을 때, 코드가 의도한 대로 동작하지 않거나 예기치 않은 오류가 발생하는 것을 방지할 수 있다.

### 생성자 함수와 클래스

ES6 이후에는 클래스 문법이 도입되었으며, 클래스는 생성자 함수와 매우 유사하게 동작한다. 사실 클래스도 내부적으로는 생성자 함수로 구현된다. 클래스는 기존 생성자 함수에 비해 문법적으로 간결하고 직관적이며, 특히 상속과 같은 객체지향 프로그래밍 패턴을 보다 쉽게 구현할 수 있게 해준다.

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const john = new Person('John', 30);
john.greet(); // Hello, my name is John
```

위 코드는 생성자 함수로 작성된 예제와 동일한 결과를 보여주지만, 클래스 문법을 사용하여 더 명확하고 읽기 쉬운 코드를 작성할 수 있다. 클래스는 상속을 지원하며, `super` 키워드를 통해 부모 클래스의 생성자와 메서드를 호출할 수 있다.

### new.target과 클래스

`new.target`은 클래스에서도 동일하게 동작한다. 클래스를 생성자 함수처럼 사용하려고 할 때, `new.target`을 이용해 이 클래스가 `new` 키워드와 함께 호출되었는지를 확인할 수 있다.

```js
class Rectangle {
  constructor(width, height) {
    if (!new.target) {
      throw new Error('Rectangle은 new를 사용하여 호출해야 합니다.');
    }
    this.width = width;
    this.height = height;
  }
}

const rect = new Rectangle(10, 20); // 정상 작동
const rect2 = Rectangle(10, 20); // Error: Rectangle은 new를 사용하여 호출해야 합니다.
```

위 예제에서 `Rectangle` 클래스는 `new` 없이 호출될 경우 에러를 발생시키도록 설계되어 있다. 이를 통해 클래스의 사용을 더 안전하게 관리할 수 있다.

### 정ㅣ

생성자 함수는 자바스크립트에서 객체를 생성하는 중요한 패턴이다. `new` 키워드를 통해 호출되며, 객체를 초기화하고 반환하는 역할을 한다. 이 과정에서 `this`, 프로토타입, `new.target` 같은 개념들이 중요한 역할을 한다. ES6 이후에는 클래스 문법이 도입되어 생성자 함수를 더욱 간결하고 명확하게 사용할 수 있게 되었으며, 여전히 `new`와 `new.target` 같은 개념은 클래스에서도 유용하게 사용된다.
